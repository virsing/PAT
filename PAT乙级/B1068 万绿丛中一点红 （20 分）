对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 M×N 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。

输入格式：

输入第一行给出三个正整数，分别是 M 和 N（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 [0,2​24​​) 内。所有同行数字间用空格或 TAB 分开。

输出格式：

在一行中按照 (x, y): color 的格式输出所求像素点的位置以及颜色值，其中位置 x 和 y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 Not Unique；如果这样的点不存在，则输出 Not Exist。

输入样例 1：

8 6 2000 	 0 	  0 	   0	    0 	     0 	      0        065280 	 65280    65280    16711479 65280    65280    65280    6528016711479 65280    65280    65280    16711680 65280    65280    6528065280 	 65280    65280    65280    65280    65280    165280   16528065280 	 65280 	  16777015 65280    65280    165280   65480    16528016777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215

输出样例 1：

(5, 3): 16711680


输入样例 2：

4 5 20 0 0 00 0 3 00 0 0 00 5 0 00 0 0 0

输出样例 2：

Not Unique


输入样例 3：

3 3 51 2 33 4 55 6 7

输出样例 3：

Not Exist


思路：题目要求符合条件的点必须是唯一的且与周围灰度值差异均超过给定的tol，可以使用map做哈希表，输入时统计像素出现的次数，然后再次遍历，统计像素仅出现了一次且 差异性符合条件的点，最后根据符合条件的点cnt的个数对应输出。

参考代码：
--------------------- 
#include<cstdio>
#include<unordered_map>
using namespace std;
int m,n,tol,cnt=0,row=-1,col=-1,a[1010][1010];
int x[10]={-1,-1,-1,0,0,1,1,1};
int y[10]={-1,0,1,-1,1,-1,0,1};
unordered_map<int,int> mp;		//哈希表，用于统计该像素出现次数
bool judge(int i,int j){		//判断与周围差异
	for(int k=0;k<8;k++)
		if(i+x[k]>=1&&i+x[k]<=n&&j+y[k]>=1&&j+y[k]<=m&&abs(a[i][j]-a[i+x[k]][j+y[k]])<=tol)
			return false;
	return true;
}
int main()
{
	scanf("%d%d%d",&m,&n,&tol);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
			mp[a[i][j]]++;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[a[i][j]]==1&&judge(i,j)){
				row=i;
				col=j;
				cnt++;
			}
		}
	}
	if(cnt==0) printf("Not Exist\n");
	else if(cnt==1) printf("(%d, %d): %d\n",col,row,a[row][col]);
	else printf("Not Unique\n");
	return 0;
}
