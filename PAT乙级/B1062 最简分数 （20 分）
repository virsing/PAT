一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。

现给定两个不相等的正分数 N​1​​/M​1​​ 和 N​2​​/M​2​​，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。

输入格式：

输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。

输出格式：

在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。

输入样例：

7/18 13/20 12


输出样例：

5/12 7/12


思路：两个分数分别为 n1/m1 n2/m2，给定的分母为k，假设满足条件的分子为x，则有n1/m1<x/k<n2/m2，因此让x从1开始累加，直到有x*m1>k*n1，此时有n1/m1<x/k，接下来的x/k一直到不小于n2/m2为止，判断是否为最简分数并输出即可。最简分数的判断，可以写一个求取最大公约数的函数gcd（），当最大公约数为1时说明分子分母没有公约数。注意：给出的这两个分数大小关系是不确定的，因此如果第一个分数较大，则要交换二者再计算。

参考代码：
--------------------- 
#include<cstdio>
#include<algorithm>
using namespace std;
int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
}
int main()
{
	int n1,m1,n2,m2,k,x=1,cnt=0;
	scanf("%d/%d %d/%d %d",&n1,&m1,&n2,&m2,&k);
	if(n1*m2>n2*m1) {		//如果第一个分数小于第二个分数，交换二者
		swap(n1,n2);
		swap(m1,m2);
	}
	while(x*m1<=n1*k) x++;
	while(x*m2<n2*k){
		int d=gcd(x,k);
		if(d==1){
			printf(cnt==0?"%d/%d":" %d/%d",x,k);
			cnt++;
		}
		x++;
	}
	printf("\n");
	return 0;
}
