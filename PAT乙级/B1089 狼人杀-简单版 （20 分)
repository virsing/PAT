以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？

本题是这个问题的升级版：已知 NNN 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？

输入格式：

输入在第一行中给出一个正整数 NNN（5≤N≤1005 \le N \le 1005≤N≤100）。随后 NNN 行，第 iii 行给出第 iii 号玩家说的话（1≤i≤N1 \le i \le N1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。

输出格式：

如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],...,a[M]A = { a[1], ..., a[M] }A=a[1],...,a[M] 和 B=b[1],...,b[M]B = { b[1], ..., b[M] }B=b[1],...,b[M]，若存在 0≤k<M0 \le k < M0≤k<M 使得 a[i]=b[i]a[i]=b[i]a[i]=b[i] （i≤ki \le ki≤k），且 a[k+1]<b[k+1]a[k+1]<b[k+1]a[k+1]<b[k+1]，则称序列 AAA 小于序列 BBB。若无解则输出 No Solution。

输入样例 1：

5-2+3-4+5+4

输出样例 1：

1 4


输入样例 2：

6+6+3+1-5-2+4

输出样例 2（解不唯一）：

1 5


输入样例 3：

5-2-3-4-5-1

输出样例 3：

No Solution


思路：假设i和j是狼人，使用两个for循环，令i从1到n，j从i+1到n，逐一判断 ，如果 i 和  j 满足所有人中恰好有两个人说谎且其中一人是狼人，则为答案。

参考代码：
--------------------- 
#include<cstdio>
using namespace std;
int n,v[110];
bool judge(int a,int b){	//假设a和b是狼人，判断是否满足一个狼人说谎且另一个没说谎，并且说谎的总人数为2
	int cnt1=0,cnt2=0;	//cnt1统计说谎的狼人数，cnt2统计说谎总人数
	for(int i=1;i<=n;i++){
		if((v[i]>0&&(v[i]==a||v[i]==b))||(v[i]<0&&(v[i]!=-a&&v[i]!=-b))){		//i说谎了
			cnt2++;
			if(i==a||i==b) 
				cnt1++;
		}
	}
	if(cnt2==2&&cnt1==1) return true;
	else return false;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&v[i]);
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(judge(i,j)) {
				printf("%d %d\n",i,j);
				return 0;
			}
		}
	}
	printf("No Solution\n");
	return 0;
}
