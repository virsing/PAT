In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination.



Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 100), the number of subway lines. Then N lines follow, with the i-th (i=1,⋯,N) line describes the i-th subway line in the format:

M S[1] S[2] ... S[M]

where M (≤ 100) is the number of stops, and S[i]'s (i=1,⋯,M) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order -- that is, the train travels between S[i] and S[i+1] (i=1,⋯,M−1) without any stop.

Note: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called "transfer stations"), no station can be the conjunction of more than 5 lines.

After the description of the subway, another positive integer K (≤ 10) is given. Then K lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively.

The following figure shows the sample map.



Note: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers.

Output Specification:

For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following:

Take Line#X1 from S1 to S2.Take Line#X2 from S2 to S3.......

where Xi's are the line numbers and Si's are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed.

If the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique.

Sample Input:

47 1001 3212 1003 1204 1005 1306 77979 9988 2333 1204 2006 2005 2004 2003 2302 200113 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 30114 6666 8432 4011 130633011 30136666 20012004 3001

Sample Output:

2Take Line#3 from 3011 to 3013.10Take Line#4 from 6666 to 1306.Take Line#3 from 1306 to 2302.Take Line#2 from 2302 to 2001.6Take Line#2 from 2004 to 1204.Take Line#1 from 1204 to 1306.Take Line#3 from 1306 to 3001.

题意：给出一张地铁交通图，再给出q对出发地st和目的地ed，让你打印出 从st到ed经停站最少的路线，如果有多条路线，则打印出中转换乘站最少的路线，保证唯一。

思路：使用map<int,int> line标记出任意两个相邻地点对应的地铁线路号，接下来使用DFS求出从st到ed的每一条路线，使用全局变量minCnt，minTransfer分别标记最少经停站和最少中转站，在DFS过程中记录下经停站数量cnt，每当找到一条到达ed的线路，就对比经停站和中转站数量，求最优解。DFS结束后即可得到一条经停站和中转站最少的路线，在输出这条path。输出时，使用preLine标记上一条地铁路线，preTransfer标记上一个中转站，然后每次变换地铁线路时，都输出上一条线路，和对应的两个站，最后终点站单独输出。

参考代码：
--------------------- 
#include<cstdio>
#include<vector>
#include<unordered_map>
using namespace std;
const int maxn=10010;
int n,q,vis[maxn],st,ed,minCnt,minTransfer;
vector<int> adj[maxn];
vector<int> tempPath,path;
unordered_map<int,int> line;
int TransferCnt(vector<int> a){			//求线路中中转站的个数
	int cnt=-1,pre=0;	//cnt统计数量，pre标记上一个中转站
	for(int i=1;i<a.size();i++){
		if(line[a[i-1]*10000+a[i]]!=pre)
			cnt++;
		pre=line[a[i-1]*10000+a[i]];
	}
	return cnt;
}
void DFS(int u,int cnt){
	if(u==ed&&(cnt<minCnt||(cnt==minCnt&&TransferCnt(tempPath)<minTransfer))){
		minCnt=cnt;
		minTransfer=TransferCnt(tempPath);
		path=tempPath;		
		return;
	}
	if(u==ed) return;
	for(int i=0;i<adj[u].size();i++){
		int v=adj[u][i];
		if(!vis[v]){
			vis[v]=1;
			tempPath.push_back(v);
			DFS(v,cnt+1);
			vis[v]=0;
			tempPath.pop_back();
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int m,pre,t;
		scanf("%d%d",&m,&pre);
		for(int j=1;j<m;j++){
			scanf("%d",&t);
			adj[pre].push_back(t);
			adj[t].push_back(pre);
			line[pre*10000+t]=i;
			line[t*10000+pre]=i;
			pre=t;
		}
	}
	scanf("%d",&q);
	for(int i=0;i<q;i++){
		scanf("%d%d",&st,&ed);
		minCnt=99999,minTransfer=99999;
		tempPath.clear();
		vis[st]=1;
		tempPath.push_back(st);
		DFS(st,0);
		vis[st]=0;
		printf("%d\n",minCnt);
		int preLine=0,preTransfer=st;
		for(int j=1;j<path.size();j++){
			if(line[path[j-1]*10000+path[j]]!=preLine){
				if(preLine!=0) printf("Take Line#%d from %04d to %04d.\n",preLine,preTransfer,path[j-1]);
				preLine=line[path[j-1]*10000+path[j]];
				preTransfer=path[j-1];
			}
		}
		printf("Take Line#%d from %04d to %04d.\n",preLine,preTransfer,ed);
	}
	return 0;
}
